#!/bin/bash
# Configuration file generation from installation session data
# Generates all configuration files needed for the system

# Source common functions
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/common.sh"

# ============================================================================
# Main config.yaml Generation
# ============================================================================

generate_config_yaml() {
  local session_file="$1"
  local output_file="$2"

  print_step "Generating config.yaml..."

  # Backup existing config if present
  backup_file "$output_file"

  # Start building the YAML
  cat > "$output_file" << 'EOF'
# Matrix Chat Support Widget - Multi-Department Configuration
# Auto-generated by installation script

# Multi-department configuration with multi-user support
departments:
EOF

  # Generate departments
  local dept_count=$(jq -r '.departments | length' "$session_file")

  for ((d=0; d<dept_count; d++)); do
    local dept_id=$(jq -r ".departments[$d].id" "$session_file")
    local dept_name=$(jq -r ".departments[$d].name" "$session_file")
    local dept_desc=$(jq -r ".departments[$d].description" "$session_file")
    local dept_icon=$(jq -r ".departments[$d].icon" "$session_file")
    local dept_color=$(jq -r ".departments[$d].color" "$session_file")
    local user_count=$(jq -r ".departments[$d].users | length" "$session_file")

    # Get primary user (first user in array)
    local primary_user=$(jq -r ".departments[$d].users[0].username" "$session_file")
    local primary_token=$(jq -r ".departments[$d].users[0].access_token" "$session_file")
    local primary_user_id=$(jq -r ".departments[$d].users[0].matrix_user_id" "$session_file")
    local admin_token=$(jq -r ".matrix.admin_token" "$session_file")
    local homeserver=$(jq -r ".matrix.homeserver_url" "$session_file")

    cat >> "$output_file" << EOF
  - id: "$dept_id"
    name: "$dept_name"
    description: "$dept_desc"
    icon: "$dept_icon"
    color: "$dept_color"
    users:
EOF

    # Add all users for this department
    for ((u=0; u<user_count; u++)); do
      local username=$(jq -r ".departments[$d].users[$u].username" "$session_file")
      local display_name=$(jq -r ".departments[$d].users[$u].display_name" "$session_file")
      local user_id=$(jq -r ".departments[$d].users[$u].matrix_user_id" "$session_file")
      local token=$(jq -r ".departments[$d].users[$u].access_token" "$session_file")
      local telegram_enabled=$(jq -r ".departments[$d].users[$u].telegram_enabled" "$session_file")

      cat >> "$output_file" << EOF
      - username: "$username"
        display_name: "$display_name"
        matrix_user_id: "$user_id"
        access_token: "$token"
        telegram_enabled: $telegram_enabled
EOF
    done

    cat >> "$output_file" << EOF
    matrix:
      homeserver: "$homeserver"
      access_token: "$primary_token"
      admin_access_token: "$admin_token"
      support_room_id: null
      bot_user_id: "$primary_user_id"
      department_users:
EOF

    # Add all department user IDs
    for ((u=0; u<user_count; u++)); do
      local user_id=$(jq -r ".departments[$d].users[$u].matrix_user_id" "$session_file")
      cat >> "$output_file" << EOF
        - "$user_id"
EOF
    done

    cat >> "$output_file" << EOF
      spaceConfig:
        channelId: "web-chat"
        autoCreateDepartmentSpace: true
        departmentSpaceNaming: "Web-Chat - $dept_name"
    widget:
      greeting: "Hi! How can our $dept_name team help you today?"
      placeholder_text: "Describe your issue or question..."

EOF
  done

  # Add legacy matrix configuration
  local admin_token=$(jq -r ".matrix.admin_token" "$session_file")
  local homeserver=$(jq -r ".matrix.homeserver_url" "$session_file")

  cat >> "$output_file" << EOF
# Legacy Matrix configuration (used as fallback)
matrix:
  homeserver: "$homeserver"
  access_token: "$admin_token"
  admin_access_token: "$admin_token"
  support_room_id: null
  bot_user_id: "@admin:localhost"

EOF

  # Add widget configuration
  local widget_title=$(jq -r ".widget.title" "$session_file")
  local widget_color=$(jq -r ".widget.brand_color" "$session_file")
  local widget_position=$(jq -r ".widget.position" "$session_file")

  cat >> "$output_file" << EOF
# Widget appearance and behavior
widget:
  title: "$widget_title"
  subtitle: "We're here to help!"
  brand_color: "$widget_color"
  position: "$widget_position"

  # Department selection configuration
  department_selection:
    title: "How can we help you today?"
    subtitle: "Choose the team that best matches your needs"
    show_descriptions: true
    layout: "grid"

EOF

  # Add Telegram configuration if enabled
  local has_telegram=$(jq -r '.telegram.enabled' "$session_file")

  if [ "$has_telegram" = "true" ]; then
    local bot_username=$(jq -r '.telegram.bot_username' "$session_file")
    local bot_token=$(jq -r '.telegram.bot_token' "$session_file")

    cat >> "$output_file" << EOF
# Social Media Integration (Telegram)
social_media:
  - id: "telegram_support"
    name: "Telegram Bot"
    platform: "telegram"
    icon: "✈️"
    color: "#0088cc"
    enabled: true
    config:
      bot_username: "$bot_username"
      bot_token: "$bot_token"
      welcome_message: "Welcome! Please select the department you need help with."
      auto_reply: true
      departments:
EOF

    # Add department mappings for Telegram
    for ((d=0; d<dept_count; d++)); do
      local dept_id=$(jq -r ".departments[$d].id" "$session_file")
      local dept_command="/start_${dept_id}"

      cat >> "$output_file" << EOF
        - department_id: "$dept_id"
          command: "$dept_command"
          channel_specific: true
EOF
    done

    cat >> "$output_file" << EOF
      working_hours:
        enabled: false

EOF

    # Add communication channels
    cat >> "$output_file" << EOF
# Communication Channels Configuration
communication_channels:
  - type: "web"
    id: "web_chat"
    name: "Web Chat"
    description: "Chat directly with our support team"
    icon: "💬"
    color: "$widget_color"
    available: true
  - type: "social"
    id: "telegram_channel"
    name: "Telegram"
    description: "Continue the conversation on Telegram"
    icon: "✈️"
    color: "#0088cc"
    available: true
    social_media_id: "telegram_support"

EOF
  else
    cat >> "$output_file" << EOF
# Social Media Integration
social_media: []

# Communication Channels Configuration
communication_channels:
  - type: "web"
    id: "web_chat"
    name: "Web Chat"
    description: "Chat directly with our support team"
    icon: "💬"
    color: "$widget_color"
    available: true

EOF
  fi

  # Add server configuration
  local server_port=$(jq -r ".widget.port" "$session_file")

  cat >> "$output_file" << EOF
# Server configuration
server:
  port: $server_port
  cors_origins:
    - "http://localhost:3000"
    - "http://localhost:5173"
    - "http://localhost:8000"
    - "file://"
  static_path: "./dist/widget"

# Logging configuration
logging:
  level: "info"
  file: null
EOF

  print_success "Generated: $output_file"
}

# ============================================================================
# Telegram Bot Script Generation
# ============================================================================

generate_telegram_bot_script() {
  local session_file="$1"
  local output_file="$2"

  # Check if file exists and is production version (contains recent fixes)
  if [ -f "$output_file" ]; then
    # Check for space persistence features (indicates production version)
    if grep -q "verifyRoomAccess" "$output_file" 2>/dev/null; then
      print_warning "Production telegram-department-router.js detected - preserving existing file"
      print_info "File contains critical fixes and will NOT be overwritten"
      print_info "To regenerate (not recommended), delete: $output_file"
      return 0
    else
      print_warning "Outdated telegram-department-router.js found - will upgrade"
      backup_file "$output_file"
    fi
  fi

  print_step "Generating telegram-department-router.js..."

  local homeserver=$(jq -r ".matrix.homeserver_url" "$session_file")
  local admin_token=$(jq -r ".matrix.admin_token" "$session_file")
  local bot_token=$(jq -r ".telegram.bot_token" "$session_file")
  local bot_username=$(jq -r ".telegram.bot_username" "$session_file")

  cat > "$output_file" << 'EOFSCRIPT'
#!/usr/bin/env node

/**
 * Telegram Department Router for Matrix Chat Support Widget
 * AUTO-GENERATED - Edit with caution
 */

const TelegramBot = require('node-telegram-bot-api');
const axios = require('axios');
const fs = require('fs');

// Store mapping between Telegram chats and Matrix rooms
const chatRoomMapping = new Map();
const roomChatMapping = new Map();

// Persistent storage for mappings
const MAPPINGS_FILE = '../data/chat-room-mappings.json';

// Load mappings from file
function loadMappings() {
  try {
    if (fs.existsSync(MAPPINGS_FILE)) {
      const data = JSON.parse(fs.readFileSync(MAPPINGS_FILE, 'utf8'));
      if (data.chatRoomMapping) {
        for (const [chatId, mapping] of Object.entries(data.chatRoomMapping)) {
          chatRoomMapping.set(parseInt(chatId), mapping);
        }
      }
      if (data.roomChatMapping) {
        for (const [roomId, chatId] of Object.entries(data.roomChatMapping)) {
          roomChatMapping.set(roomId, parseInt(chatId));
        }
      }
      console.log(`📂 Loaded ${chatRoomMapping.size} chat-room mappings from storage`);
    }
  } catch (error) {
    console.error('❌ Failed to load mappings:', error.message);
  }
}

// Save mappings to file
function saveMappings() {
  try {
    const data = {
      chatRoomMapping: Object.fromEntries(chatRoomMapping),
      roomChatMapping: Object.fromEntries(roomChatMapping),
      lastUpdated: new Date().toISOString()
    };
    const dataDir = '../data';
    if (!fs.existsSync(dataDir)) {
      fs.mkdirSync(dataDir, { recursive: true });
    }
    fs.writeFileSync(MAPPINGS_FILE, JSON.stringify(data, null, 2));
    console.log(`💾 Saved ${chatRoomMapping.size} chat-room mappings to storage`);
  } catch (error) {
    console.error('❌ Failed to save mappings:', error.message);
  }
}

EOFSCRIPT

  # Add configuration from session
  cat >> "$output_file" << EOFSCRIPT

// Matrix configuration
const MATRIX_HOMESERVER = '$homeserver';
const ADMIN_ACCESS_TOKEN = '$admin_token';

// Telegram bot configuration
const BOT_USERNAME = '$bot_username';
const bot = new TelegramBot('$bot_token', { polling: true });

// Department configuration
const TELEGRAM_DEPARTMENT_SPACES = {
EOFSCRIPT

  # Generate department configurations
  local dept_count=$(jq -r '.departments | length' "$session_file")

  for ((d=0; d<dept_count; d++)); do
    local dept_id=$(jq -r ".departments[$d].id" "$session_file")
    local dept_name=$(jq -r ".departments[$d].name" "$session_file")
    local dept_icon=$(jq -r ".departments[$d].icon" "$session_file")
    local user_count=$(jq -r ".departments[$d].users | length" "$session_file")

    cat >> "$output_file" << EOFSCRIPT
  '$dept_id': {
    spaceId: null,
    name: 'Telegram - $dept_name',
    icon: '$dept_icon',
    command: '/start_$dept_id',
    users: [
EOFSCRIPT

    # Add all users for this department
    for ((u=0; u<user_count; u++)); do
      local user_id=$(jq -r ".departments[$d].users[$u].matrix_user_id" "$session_file")
      local comma=""
      if [ $u -lt $((user_count - 1)) ]; then
        comma=","
      fi
      cat >> "$output_file" << EOFSCRIPT
      '$user_id'$comma
EOFSCRIPT
    done

    local comma=""
    if [ $d -lt $((dept_count - 1)) ]; then
      comma=","
    fi

    cat >> "$output_file" << EOFSCRIPT
    ]
  }$comma
EOFSCRIPT
  done

  cat >> "$output_file" << EOFSCRIPT
};

// Main Telegram space
let MAIN_TELEGRAM_SPACE_ID = null;

// Load existing mappings on startup
loadMappings();
EOFSCRIPT

  # Add the rest of the bot implementation (space creation, message handling, etc.)
  cat >> "$output_file" << 'EOFSCRIPT'

// Create Telegram spaces if they don't exist
async function createTelegramSpaces() {
  console.log('🔧 Creating/ensuring Telegram spaces exist...');

  try {
    // Create main Telegram Support space
    if (!MAIN_TELEGRAM_SPACE_ID) {
      const mainSpaceResponse = await axios.post(`${MATRIX_HOMESERVER}/_matrix/client/v3/createRoom`, {
        name: 'Telegram Support',
        topic: 'Main space for all Telegram customer support conversations',
        creation_content: { type: 'm.space' },
        power_level_content_override: {
          users: { '@admin:localhost': 100 }
        },
        initial_state: [
          { type: 'm.room.history_visibility', content: { history_visibility: 'shared' } },
          { type: 'm.room.guest_access', content: { guest_access: 'can_join' } },
          { type: 'm.room.join_rules', content: { join_rule: 'invite' } }
        ]
      }, {
        headers: {
          'Authorization': `Bearer ${ADMIN_ACCESS_TOKEN}`,
          'Content-Type': 'application/json'
        }
      });

      MAIN_TELEGRAM_SPACE_ID = mainSpaceResponse.data.room_id;
      console.log(`✅ Main Telegram space: ${MAIN_TELEGRAM_SPACE_ID}`);
    }

    // Create department spaces
    for (const [departmentId, department] of Object.entries(TELEGRAM_DEPARTMENT_SPACES)) {
      if (!department.spaceId) {
        const deptSpaceResponse = await axios.post(`${MATRIX_HOMESERVER}/_matrix/client/v3/createRoom`, {
          name: department.name,
          topic: `${department.name} via Telegram`,
          creation_content: { type: 'm.space' },
          power_level_content_override: {
            users: {
              '@admin:localhost': 100,
              ...Object.fromEntries(department.users.map(u => [u, 50]))
            }
          },
          initial_state: [
            { type: 'm.room.history_visibility', content: { history_visibility: 'shared' } },
            { type: 'm.room.guest_access', content: { guest_access: 'can_join' } },
            { type: 'm.room.join_rules', content: { join_rule: 'invite' } }
          ]
        }, {
          headers: {
            'Authorization': `Bearer ${ADMIN_ACCESS_TOKEN}`,
            'Content-Type': 'application/json'
          }
        });

        department.spaceId = deptSpaceResponse.data.room_id;
        console.log(`✅ Department space: ${department.name} - ${department.spaceId}`);

        // Add to main space
        await axios.put(`${MATRIX_HOMESERVER}/_matrix/client/v3/rooms/${MAIN_TELEGRAM_SPACE_ID}/state/m.space.child/${department.spaceId}`, {
          via: ['localhost'],
          suggested: true,
          order: departmentId
        }, {
          headers: {
            'Authorization': `Bearer ${ADMIN_ACCESS_TOKEN}`,
            'Content-Type': 'application/json'
          }
        });

        // Set parent relationship
        await axios.put(`${MATRIX_HOMESERVER}/_matrix/client/v3/rooms/${department.spaceId}/state/m.space.parent/${MAIN_TELEGRAM_SPACE_ID}`, {
          via: ['localhost'],
          canonical: true
        }, {
          headers: {
            'Authorization': `Bearer ${ADMIN_ACCESS_TOKEN}`,
            'Content-Type': 'application/json'
          }
        });
      }
    }

    console.log('✅ All Telegram spaces ready');
  } catch (error) {
    console.error('❌ Error creating Telegram spaces:', error.message);
  }
}

// Ensure all department users are invited to their spaces
async function ensureDepartmentUsersInSpaces() {
  console.log('🔧 Ensuring department users are invited to their spaces...');

  for (const [departmentId, department] of Object.entries(TELEGRAM_DEPARTMENT_SPACES)) {
    for (const userId of department.users) {
      try {
        await axios.post(`${MATRIX_HOMESERVER}/_matrix/client/v3/rooms/${department.spaceId}/invite`, {
          user_id: userId
        }, {
          headers: {
            'Authorization': `Bearer ${ADMIN_ACCESS_TOKEN}`,
            'Content-Type': 'application/json'
          }
        });
        console.log(`📧 Invited ${userId} to ${department.name}`);
      } catch (error) {
        // User might already be in space
      }
    }
  }
}

// Create Matrix room for Telegram chat
async function createDepartmentRoom(departmentId, telegramUser, telegramChatId) {
  const department = TELEGRAM_DEPARTMENT_SPACES[departmentId];
  if (!department) {
    throw new Error(`Unknown department: ${departmentId}`);
  }

  const roomName = `Telegram Chat - ${telegramUser.first_name || telegramUser.username || telegramChatId}`;
  const roomTopic = `Support chat with Telegram user @${telegramUser.username || telegramUser.first_name} (${telegramChatId})`;

  try {
    // Create room and invite ALL department users
    const roomResponse = await axios.post(`${MATRIX_HOMESERVER}/_matrix/client/v3/createRoom`, {
      name: roomName,
      topic: roomTopic,
      visibility: 'private',
      preset: 'private_chat',
      invite: department.users,  // Invite all users
      initial_state: [{
        type: 'm.room.power_levels',
        content: {
          users: {
            '@admin:localhost': 100,
            ...Object.fromEntries(department.users.map(u => [u, 50]))
          }
        }
      }]
    }, {
      headers: {
        'Authorization': `Bearer ${ADMIN_ACCESS_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });

    const roomId = roomResponse.data.room_id;
    console.log(`✅ Created room ${roomId} with ${department.users.length} users`);

    // Add room to department space
    await axios.put(`${MATRIX_HOMESERVER}/_matrix/client/v3/rooms/${department.spaceId}/state/m.space.child/${roomId}`, {
      via: ['localhost'],
      suggested: true,
      order: new Date().getTime().toString()
    }, {
      headers: {
        'Authorization': `Bearer ${ADMIN_ACCESS_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });

    await axios.put(`${MATRIX_HOMESERVER}/_matrix/client/v3/rooms/${roomId}/state/m.space.parent/${department.spaceId}`, {
      via: ['localhost'],
      canonical: true
    }, {
      headers: {
        'Authorization': `Bearer ${ADMIN_ACCESS_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });

    console.log(`🏢 Added room to ${department.name} space`);

    return {
      roomId,
      departmentName: department.name,
      spaceId: department.spaceId
    };
  } catch (error) {
    console.error('❌ Error creating department room:', error.response?.data || error.message);
    throw error;
  }
}

// Generate dynamic keyboard
function generateDepartmentKeyboard() {
  const keyboard = [];
  const departments = Object.entries(TELEGRAM_DEPARTMENT_SPACES);

  for (let i = 0; i < departments.length; i += 2) {
    const row = [];
    const [id1, dept1] = departments[i];
    row.push({
      text: `${dept1.icon} ${dept1.name.replace('Telegram - ', '')}`,
      callback_data: `dept_${id1}`
    });

    if (departments[i + 1]) {
      const [id2, dept2] = departments[i + 1];
      row.push({
        text: `${dept2.icon} ${dept2.name.replace('Telegram - ', '')}`,
        callback_data: `dept_${id2}`
      });
    }

    keyboard.push(row);
  }

  return { inline_keyboard: keyboard };
}

// Send welcome message with department selection
async function sendWelcomeMessage(chatId) {
  const welcomeMessage = `
🎧 **Welcome to Customer Support!**

Please select the department that best matches your needs:
`;

  await bot.sendMessage(chatId, welcomeMessage, {
    parse_mode: 'Markdown',
    reply_markup: generateDepartmentKeyboard()
  });
}

// Handle department selection
async function handleDepartmentSelection(departmentId, telegramUser, chatId) {
  try {
    const department = TELEGRAM_DEPARTMENT_SPACES[departmentId];

    if (!department) {
      await bot.sendMessage(chatId, '❌ Invalid department. Please use /start to begin again.');
      return;
    }

    // Check if already connected
    if (chatRoomMapping.has(chatId)) {
      const existing = chatRoomMapping.get(chatId);
      await bot.sendMessage(chatId, `You're already connected to ${existing.departmentId}. Send your message!`);
      return;
    }

    // Create Matrix room
    const roomInfo = await createDepartmentRoom(departmentId, telegramUser, chatId);

    // Store mapping
    chatRoomMapping.set(chatId, {
      roomId: roomInfo.roomId,
      departmentId: departmentId,
      userId: telegramUser.id,
      username: telegramUser.username || telegramUser.first_name
    });

    roomChatMapping.set(roomInfo.roomId, chatId);
    saveMappings();

    await bot.sendMessage(chatId, `✅ You're connected to **${department.name.replace('Telegram - ', '')}**! Send your message and our team will respond shortly.`, {
      parse_mode: 'Markdown'
    });

    // Send context to Matrix
    await axios.put(`${MATRIX_HOMESERVER}/_matrix/client/v3/rooms/${roomInfo.roomId}/send/m.room.message/${Date.now()}`, {
      msgtype: 'm.notice',
      body: `New Telegram conversation started\nUser: @${telegramUser.username || telegramUser.first_name}\nTelegram ID: ${chatId}\nDepartment: ${department.name}`
    }, {
      headers: {
        'Authorization': `Bearer ${ADMIN_ACCESS_TOKEN}`,
        'Content-Type': 'application/json'
      }
    });

    console.log(`🎯 User ${telegramUser.username || chatId} connected to ${department.name} with ${department.users.length} agents`);
  } catch (error) {
    console.error('❌ Error handling department selection:', error);
    await bot.sendMessage(chatId, '❌ Sorry, there was an error connecting you to support. Please try again.');
  }
}

// Bot command handlers
bot.onText(/\/start/, async (msg) => {
  await sendWelcomeMessage(msg.chat.id);
});

bot.onText(/\/help/, async (msg) => {
  await sendWelcomeMessage(msg.chat.id);
});

// Inline keyboard callbacks
bot.on('callback_query', async (callbackQuery) => {
  const message = callbackQuery.message;
  const data = callbackQuery.data;

  if (data.startsWith('dept_')) {
    const departmentId = data.replace('dept_', '');
    await handleDepartmentSelection(departmentId, callbackQuery.from, message.chat.id);
    await bot.answerCallbackQuery(callbackQuery.id);
  }
});

// Handle regular messages for bridging
bot.on('message', async (msg) => {
  if (msg.text && msg.text.startsWith('/')) {
    return;
  }

  if (msg.reply_to_message) {
    return;
  }

  const chatId = msg.chat.id;
  const mapping = chatRoomMapping.get(chatId);

  if (mapping && msg.text) {
    try {
      await axios.put(`${MATRIX_HOMESERVER}/_matrix/client/v3/rooms/${mapping.roomId}/send/m.room.message/${Date.now()}`, {
        msgtype: 'm.text',
        body: msg.text,
        format: 'org.matrix.custom.html',
        formatted_body: `<strong>${mapping.username}:</strong> ${msg.text}`
      }, {
        headers: {
          'Authorization': `Bearer ${ADMIN_ACCESS_TOKEN}`,
          'Content-Type': 'application/json'
        }
      });

      console.log(`📨 Forwarded message from ${mapping.username} to Matrix room ${mapping.roomId}`);
    } catch (error) {
      console.error('❌ Error forwarding message to Matrix:', error.response?.data || error.message);
    }
  }
});

// Matrix event stream for Matrix-to-Telegram bridging
const ROUTER_START_TIME = Date.now();
const processedMessages = new Set();

async function startMatrixEventStream() {
  try {
    const syncResponse = await axios.get(`${MATRIX_HOMESERVER}/_matrix/client/v3/sync?filter={"room":{"timeline":{"limit":0}}}`, {
      headers: { 'Authorization': `Bearer ${ADMIN_ACCESS_TOKEN}` }
    });

    let nextBatch = syncResponse.data.next_batch;
    console.log('🔄 Starting Matrix event stream (only new messages)...');

    setInterval(async () => {
      try {
        const syncResponse = await axios.get(`${MATRIX_HOMESERVER}/_matrix/client/v3/sync?since=${nextBatch}&timeout=30000`, {
          headers: { 'Authorization': `Bearer ${ADMIN_ACCESS_TOKEN}` },
          timeout: 35000
        });

        nextBatch = syncResponse.data.next_batch;

        if (syncResponse.data.rooms && syncResponse.data.rooms.join) {
          for (const [roomId, roomData] of Object.entries(syncResponse.data.rooms.join)) {
            if (roomData.timeline && roomData.timeline.events) {
              for (const event of roomData.timeline.events) {
                if (event.type === 'm.room.message' && event.content && event.content.msgtype === 'm.text') {
                  if (event.origin_server_ts > ROUTER_START_TIME) {
                    if (!processedMessages.has(event.event_id)) {
                      processedMessages.add(event.event_id);
                      await handleMatrixMessage(roomId, event);
                    }
                  }
                }
              }
            }
          }
        }
      } catch (error) {
        if (error.code !== 'ECONNABORTED') {
          console.error('❌ Matrix sync error:', error.message);
        }
      }
    }, 5000);
  } catch (error) {
    console.error('❌ Failed to start Matrix event stream:', error.message);
  }
}

async function handleMatrixMessage(roomId, event) {
  const telegramChatId = roomChatMapping.get(roomId);

  if (!telegramChatId) {
    return;
  }

  const sender = event.sender;
  const messageBody = event.content.body;

  // Skip bot messages
  if (
    sender.includes('telegram_') ||
    sender.includes(BOT_USERNAME.toLowerCase()) ||
    sender === '@admin:localhost' ||
    messageBody.includes('New Telegram conversation started') ||
    messageBody.includes('User:') ||
    messageBody.includes('Telegram ID:') ||
    event.content.msgtype === 'm.notice'
  ) {
    return;
  }

  try {
    const senderName = sender.replace('@', '').replace(':localhost', '');
    const message = `${senderName}: ${messageBody}`;

    await bot.sendMessage(telegramChatId, message);
    console.log(`📨 Forwarded Matrix message from ${senderName} to Telegram chat ${telegramChatId}`);
  } catch (error) {
    console.error('❌ Error forwarding Matrix message to Telegram:', error.message);
  }
}

// Error handling
bot.on('polling_error', (error) => {
  console.error('❌ Telegram polling error:', error.message);
});

// Initialize
async function initialize() {
  await createTelegramSpaces();
  await ensureDepartmentUsersInSpaces();
  await startMatrixEventStream();

  console.log('🤖 Telegram Department Router started');
  console.log('📱 Bot username:', BOT_USERNAME);
  console.log('🏠 Matrix homeserver:', MATRIX_HOMESERVER);
  console.log('✅ Bot ready to receive messages!');
}

initialize();
EOFSCRIPT

  chmod +x "$output_file"
  print_success "Generated: $output_file"
}

# Export functions
export -f generate_config_yaml generate_telegram_bot_script
